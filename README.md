# Decentralized Development Fund for GitLab Projects

This project aims to create a minimal-viable-demo (MVP) of **smart contract-driven funding system** that allows **funders** to allocate funds to specific **GitLab issues or features**, which will then be **claimed by developers** after their merge requests are approved and merged. The system ensures **secure payouts** via an **n-out-of-m multi-signature validation process**, where **validators** confirm the correctness of completed work before releasing funds.

A **web application** will provide an interface for **funders, developers, and validators**, integrating with **GitLab APIs** to track issue progress and merge approvals.

## Objectives

* More advanced syntax for Solidity
   * storage vs. memory vs. calldata
   * events
   * calling other contracts and contract libraries
   * contract interactions
   * multiple smart-contract deployments
* Solidity projects
   * Basic structure of Solidity project files as generated by `hardhat`
   * Basic tools: `metamask` and `hardhat`

## How to Build and Run

Follow these steps to set up, deploy, and run your smart contracts and frontend DApp.

---

### 1. Clone the Repository

Clone the project to your local machine:

```bash
git clone https://github.com/wilvang/decentralized-gitlab-funding.git
cd decentralized-gitlab-funding
```
### 2. **Node.js and Dependencies**

Make sure Node.js and npm are installed:

- **On macOS:**

```bash
brew install node
```

- **On Ubuntu/Linux:**

```bash
curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
sudo apt-get install -y nodejs
```

Install project dependencies:

```bash
npm install
```

### 3. Setup the .env File

Create a `.env` file in the root directory with the following content.
NB: Update the addresses after deployment:

```.env
INFURA_URL=https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID
PRIVATE_KEY=your_private_key_here
VALIDATORS=["0xValidatorAddress1","0xValidatorAddress2","0xValidatorAddress3"]
FUND_MANAGER_ADDRESS="REPLACE_ME"
VALIDATOR_ADDRESS="REPLACE_ME"
DEVELOPER_ADDRESS="REPLACE_ME"
```

### 4. Compile the Contracts

```bash
npx hardhat compile
```

### 5. Deploy Contracts to Sepolia (in order)

#### Step 1: FundManager
```bash
npx hardhat ignition deploy ./ignition/modules/FundManager.js --network sepolia
```
Update `FUND_MANAGER_ADDRESS` in `.env` with the deployed address.

#### Step 2: ValidatorMultiSig
```bash
npx hardhat ignition deploy ./ignition/modules/ValidatorMultiSig.js --network sepolia
```
Update `VALIDATOR_ADDRESS` in `.env`.

#### Step 3: DeveloperPayouts

```bash
npx hardhat ignition deploy ./ignition/modules/DeveloperPayouts.js --network sepolia
```
Update `DEVELOPER_ADDRESS` in `.env`.

### 6. Serve the Frontend

Host the Web3 frontend locally using:
```bash
npx serve frontend
```
Then open your browser to: http://localhost:3000

## System Roles

### Funders (Donors)

- Contribute funds to the **collective project wallet**
- Allocate funds to specific **GitLab issues or features** as **bounties**.
- Track how their funds are being used.

### Developers (Workers)

- Select **open funded issues** from GitLab.
- Work on issues and submit **merge requests**.
- Once merged, **request payment** for their work.


### Validators (Approvers)

- Act as **trusted entities** who review completed work.
- Use an **n-out-of-m** multi-signature scheme to approve work done and **payouts**.
- Can vote to **release funds** after merge request approval.



## Smart Contract Design

### Core Functionalities

* Funding & Allocation
   - Accept **donations** into a **collective funding wallet**.
   - Allow funders to **assign funds** to specific GitLab issues.
* Developer Bounty System
   - Developers can **claim an issue** and work on it.
   - Once an issue is **merged in GitLab**, the developer can **request payout.
* Multi-Signature Payout Approval
   - Validators must provide **n-out-of-m confirmations** to approve payments.
   - Funds are only released after **GitLab merge confirmation** + validator approval.
* Security & Dispute Resolution
   - Implement **reentrancy protection** for payouts.
   - Funders can **reallocate unused funds**.
   - Validators can **reject fraudulent claims** if work is incomplete or incorrect.



## Technical Implementation

The point is to explore Solidity, not web development and integration with Gitlab. Therefore, focus on smart contract design and implementation, and make assumptions that simplify the Gitlab integration part. Copy-paste of URLs or hand-handling of some notifications from/to Gitlab is acceptable.

### Smart Contracts
- **FundManager.sol** → Handles **funding, issue tracking, and bounty allocation**.
- **ValidatorMultiSig.sol** → Implements **n-out-of-m multi-signature approval** for payouts.
- **DeveloperPayouts.sol** → Allows developers to **claim bounties and receive payments**.

### GitLab Integration
- Use **GitLab API** to:
  - Track **open & funded issues**.
  - Verify when an issue is **closed via a successful merge**.
  - Fetch merge request details and verify the **author (developer)**.
- Smart contract **listens for GitLab webhooks** to automate **merge approval tracking**.

### Web Application (Frontend)
- Built with **HTML + Ethers.js** for Ethereum interaction.
- Features:
  - **Funders:** Allocate funds to GitLab issues.
  - **Developers:** View & claim bounties, request payouts.
  - **Validators:** Approve or reject payments via multi-signature voting.
  - **GitLab Integration:** View GitLab project issues, status, and merge request history.

Use assumptions and manual URL and event notifications between your app and Gitlab. Do not include full webhooks integration - this is too much for MVP.

## Payment & Validation Flow

1. **Funders** deposit coins and allocate bounties to GitLab issues.
2. **Developers** pick a funded issue and submit a merge request to GitLab.
3. **GitLab merges the request**, and a webhook **notifies the smart contract**.
4. **Developer requests payout** through the contract.
5. **Validators confirm the merge is valid** and vote (n-out-of-m multisig).
6. If threshold approvals are met, the contract **automatically releases funds**.


## Security & Best Practices

Optional considerations:
[ ] **Multi-Signature Validator System** (n-out-of-m confirmations).
[ ] **Reentrancy protection** for payouts.
[ ] **Timelocks** to prevent rushed withdrawals.
[ ] **On-chain dispute resolution** in case of invalid claims.



## Enhancements

- **Decentralized Governance**: Funders and validators vote on project rules.
- **Automated Code Quality Checks**: Use **AI or static analysis tools and Gitlab CI/CD pipeline** before payouts.



## Considerations

* Not all requirements are specified - you have to use your judgement in finalising the functional and non-functional requirements. 
* The intention is to explore a **simplified version** of a decentralized funding system. It should ONLY focus on essential smart contract functionalities.
* This is MVP (minimal viable product), that should be scoped for about 6-8 hours of work only. Do not over-engineer it and do not make bachelor thesis out of it.
* **Focus on Solidity** and smart contract design. Assume GitLab integration is handled by a separate team.
* **Use Hardhat** for development and testing.
* **Use Remix** for quick contract deployment and testing only. Try to test as much as possible in Hardhat.
* **Use local node** and local chain for deployment and testing. Do not use Sepolia.
* For integration with a MVP for the web-app, you can deploy and integrate with Sepolia.
